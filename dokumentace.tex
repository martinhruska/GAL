\documentclass[a4paper, 12pt]{article}
\usepackage[left=1.5cm, text={18cm, 25cm}, top=2.5cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[czech,english]{babel}
\usepackage{cite}
\usepackage{graphicx}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{url}
\usepackage{comment}
\usepackage[longend,ruled,vlined,commentsnumbered,linesnumbered]{algorithm2e}
\newcommand{\myuv}[1]{\quotedblbase #1\textquotedblleft}

\title{Simulation of non-deterministic finite tree automata}
\author{Martin Hruška, Petr Šebek\\\{xhrusk16, xsebek02\}@stud.fit.vutbr.cz}

\date{}
\begin{document}

\maketitle

\section{Introduction}
\label{sec:intro}

Non-deterministic finite tree automata (NTA) is formalism often used in the field of formal verification.
For example, it can be used for shape analysis of programs manipulating complex data structure where
state of heap is represented by a set of the tree automata \cite{methods12}.
The mentioned technqiue is based on the framework of abstract interpretation where one of fundamentals
operations is computing fixpoint (mainly for the cycles in a program) what includes checking inclusion of
tree automata languages.
Checking inclusion is easy for deterministict tree automata (DTA) but much harder for NTA because
naive algorithm has exponential compexity.
It is not also possbile to use DTA in these techniques because NTA can represent same language in much more
conciser way and determinization could lead to exponental grow of the states.
However, there are efficient algorithms for checking language inclusion (based on antichains introduced in \cite{tacas10})
which it is possible to make more efficient by computing simulation relation over the states of checked automata \cite{tacas10}.
Simulation reduce state space which is neede to explore to check whether inclusion holds.
On the other side, computation of simulation relation has itself quadratic complexity so the time needed
to compute it is sometimes bigger then saved state space.
This leads to need of trying the new methods for computing simulation which can be more efficient and
reduce its complexity to level when it will be efficient enough to be used always for enhancing inclusion checking. 

Being more general, simulation relation is attribute of graphs not only automata \cite{focs95, tacas08}.
In case of tree automata it is possible to compute upward or downward simulation but in this
work we consider only downward simulation.
As we mentioned earlier simulation brings reduction of states which we need explore performing
certain algorithms over tree automata because it often holds that when state $p$ is simulated by $q$
we don't further explore state $p$.
Moreover, it is possible also to perform reduction of states of a NFA by computing
equivalence classes on simulation relation and merging states in a same class.

Another technique dealing with complexity of NFA is their representation using mutli-terminal binary decision diagrams (MTBDD).
The symbols of a NFA are encoded to binary representation so the transitions can represented by shared MTBDD what is very efficient mainly for NFA with large alphabeth
(in the second possible representation -- symbols are represented explicitly for each transition).
A~NFA could be represented in bottom-up way or top-down way by MTBDD, in this work we consider only top-down way.

In this work we would like to combine straightwordness of implementation of simulation over explicitly
represented tree automata and conciser representation of automata by MTBDD.
We suppose NTA represented by MTBDD and we will compute simulation by it conversion
to explicit one with gradual reduction of number of the NFA symbols.
We use computed simulation for more efficient inclusion computation and evaluate whether the method brings any advantage.
The implementation is realized as an extension of VATA library which state-of-the-art library for NTA manipulation.

In Section \ref{sec:analysis} we give formal definitions, in Section \ref{sec:bdd} MTBDD representation of automata is described.
Section \ref{sec:bdd} describes VATA library, Section \ref{sec:vata} provides description of design of our solution.
Implementation details take place in Section \ref{sec:impl} and finally experiments are evaluated in Section \ref{sec:exps}.

\section{Preliminaries}
\label{sec:analysis}
In this section NTA and simulation over NTA states will be defined more formally.

A~\emph{ranked alphabeth} is a finite set of symbols $\Sigma$ associated with a mapping $\#: \Sigma \rightarrow \mathbb{N_0}$
that assigns ranks to symbols. A~\emph{tree} is a graph $t$ which is either empty or it has exactly one root and each of its
nodes is the $i$-th successor of at most one node $v$ for some $i \in \mathbb{N_0}$

A~\emph{finite, non-deterministic, top-down tree automata} is a quadratuple $A=(Q, \Sigma, \delta, R)$ where
$Q$ is a finite set of \emph{states}, $R\subseteq Q$ is a set of \emph{root states}, $\Sigma$ is a ranked alphabeth,
$\delta$ is a set of the transition rules.
Each transition is a triple of the form $(q,a,q_1, \ldots, q_n)$ where $n \geq 0$, $q, q_0 \ldots q_n \in Q$, $a \in \Sigma$ and $\#(a) = n$.
When $n = 0$ then such a transition is called a \emph{leaf rules}.
A~\emph{bottom-up} automaton is a quadratuple $B=(Q, \Sigma, \delta, F)$, where $Q$, $F$ are same as for $top-down$ automaton, $F\subseteq Q$
is a set of final states and $\delta$ is a transition relation with rules which are in the form $(q_1,\ldots, q_n,a,q)$ where $n \geq 0$ and $\#(a) = n$.
We can interchange the two notations because non-deterministic automata are known to have same expressive power in bottom-up and top-down version \cite{tata}.

[TODO: maybe define semantics of TA]


For a bottom-up NTA $A=(Q, \Sigma, \delta, R)$, a \emph{downward simulation} $\preceq\, \subseteq Q\times Q$ is binary relation such that $q \preceq p$
and $(q,a,q_1,\ldots, q_n),a,q)$ then $\exists (p_1, \ldots, p_n) \rightarrow p \wedge \forall i \in {1 \ldots n}: q_i \preceq p_i$.

\section{BDD representation}
\label{sec:bdd}

This section is based on~\cite{fiedor:wsks}. \textit{Reduced ordered binary decision diagram} (BDD) is directed acyclic graph with single \textit{source} node called \textit{root} and at least two \textit{sink} nodes 0 and 1. Nodes that are not sink nodes are called \textit{internal nodes}. ROBDD are defined over a set of $n$ Boolean variables $X = \{x_1, \dots, x_n\}$, we assume that $X$ can be ordered: $x_1 < x_2 < \dots < x_n$. Now for each internal node $v$, there exists two outgoing edges with label \textit{low} and \textit{high}. We further can define function \textit{var} which assign Boolean variables to the internal nodes of ROBDD. In ROBDDs there holds next condition: $var(v) < var(v.low) \wedge var(v) < var(v.high) \wedge v.low \neq v.high$, thus successor has always higher value. ROBDD nodes therefore represent $n$-ary Boolean functions that map each assignment to the Boolean variables in $X$.

\textit{Mutli terminal binary decision diagram} (MTBDD) is then ROBDD generalized to more than two sink nodes. Further we can define \textit{shared} MTBDD, MTBDD with multiple source nodes/roots. You can see difference between ordinary BDD and MTBDD in Figure \ref{fig:15860}.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.7\linewidth]{15860.pdf}
	\caption{Comparison of ROBDD and MTBDD \cite{fiedor:wsks}}
	\label{fig:15860}
\end{figure}

Let $A=(Q, \Sigma, \delta, R)$ be a tree automaton. We can encode symbols to binary sequence with some function $enc: \Sigma \rightarrow \{0, 1\}^n$, for some $n$. Each position $1\leq i \leq n$ is then assigned a Boolean variable from set $X = \{x_1, \dots, x_n\}$. We define $Q^\#$ as set of all tuples of states from $Q$ with up to the maximum arity that some symbol in $\Sigma$ has.

Finally we can define \textit{top-down} representation of the transition function $\delta$ of the TA $A$ uses a shared MTBDD $\delta^{td}$ over $\Sigma$, where the set of roots $R=Q$ and the domain of labels of sink nodes is $2^{Q^\#}$. MTBDD $\delta^{td}$ then represents the function
\begin{equation*}
[[ \delta^{td}]]  : Q \rightarrow (\Sigma \rightarrow 2^{Q^\#}t)
\end{equation*}
\begin{equation*}
[[ \delta^{td}]]   = \lambda q a . \{(q_1, \dots, q_p) | q \xrightarrow{a} (q_1, \dots, q_p) \} 
\end{equation*}

\section{VATA}
\label{sec:vata}
VATA is library for efficient manipulation with NTA \cite{libvata}.
It provides both encoding for NTA -- semi-symbolic via MTBDD and explicit which will described further.
VATA is open-source licensed under GPL license and it is written in C++.
It currently supports TIMBUK as input format.

The main goal of VATA is to provide state-of-the-art algorithms for inclusion checking
but it also contains implementation of standard operations like union or intersection.
As we mentioned in Section \ref{sec:intro} inclusion checking is related to simulation
since simulation relation could bring more efficiency to the state-of-the-art algorithms like antichains \cite{tacas10}.
There are already implemented algorithms for computing simulation in VATA but not one of them uses method which we used.
The algorithms for simulation computing in VATA uses encoding to LTL systems \cite{tacas08} in case of explicit encoding
and there are some implementations over MTBDD which are not known to work at all.

\subsection{Explicit representation}

The explcitly represented automaton is represented by it transition set using two hash maps.
The first one maps each state $q$ to the second hash map which maps symbol $a$ set of tuples $(q_1,\ldots,q_n)$ for all $a(q_1, \ldots, q_n) \rightarrow q \in \delta$.
The set of states is not stored explictly because it is possible to obtain it from transition relation.
However, a set of final states is represented like a standard set.

\subsection{Semi-Symbolic Representation}

Semi-symbolic reprentation is based on representing transition relation using MTBDD.
The particular details of encoding of a NTA to MTBDD is described in section \ref{sec:bdd}.
The VATA library provides two possible MTBDD representation -- top-down and bottomu-up.
The first one stores MTBDD for each $q \in Q$ and all transition where $q$ is on right-handed side
are represented by the MTBDD.
The MTBDD terminal symbols has are sets of tuples which it is possible to make transition from $q$ to.
The bottom-up representation inversely, MTBDD exists for each tuple of the NTA and MTBBD represents all transitions with
the tuple on left-handed side and the terminal symbols are sets of states which it is possible to make transition to.

\section{Design}
\label{sec:design}

This section describes conceptual design of our method for computing simulation and related algorithms.
For implementation design please see Section \ref{sec:impl}.

As the input of our method we take a NTA represented by MTBDD in top-down way
which we translate into a NTA represented explicitly and we also reduce symbols.
This done by following general method doing reduction of alphabeth and yielding a new NTA.
Let have a NFA $A=(Q, \Sigma, \delta, F)$, a new ranking alphabeth $\Sigma'$ and mapping $f: 2^\Sigma \rightarrow \Sigma'$,
when there is $((a_1(q_1,\ldots,q_n) \rightarrow q) \in \delta \wedge \ldots \wedge (a_n(q_1,\ldots,q_n) \rightarrow q) \in \delta) \wedge
((a_1(r_1,\ldots,r_n) \rightarrow q) \in \delta \wedge \ldots \wedge (a_n(r_1,\ldots,r_n) \rightarrow q) \in \delta)$
such that $a_i \neq a_{i+1}$ for any $i\in \{1..n\}$ then $(\{a_1, \ldots, a_n\}) \rightarrow A) \in f$.
It is also constructed a new NFA $A' = (Q, \Sigma', \delta', F)$ where $Q, F$ are unchanged to $A$ 
and $\Sigma'$ is the new ranked alphabeth obtained by mapping $f$ and $\delta'$ is transition rules set such that
$(a_1(q_1, \ldots, q_n) \rightarrow q) \in \delta \wedge \ldots \wedge (a_n(q_1, \ldots, q_n) \rightarrow q) \in \delta$ and
$ \{a_1,\ldots,a_n\}  \rightarrow A~\in f$ for some $A \in \Sigma'$, then $A(q_1, \ldots, q_n) \rightarrow q) \in \delta$
for all possible tuples $q_1,\ldots,q_n$ [TODO which tuples].
In our case, the input NFA is semi-symbolic represented one and the output NTA is the same automata in explicit representation.
The change of NTA representation is done in level of implementation details and is not directly related to a design of generic algorithm.
The whole method of translation is described again in Algortihm \ref{alg:translate} to provide more easy to follow way of method description.

\begin{algorithm}
\label{alg:translate}
\KwIn{NTA $A=(Q,\Sigma, \delta, F)$}
    \KwOut{NTA $A'=(Q,\Sigma', \delta', F)$}
    $\delta' = \emptyset $\;
    $\Sigma' = \emptyset $\;
	$f = \emptyset$\;
	\ForEach{$q \in Q$}
    {
		\ForEach{$(q_1,\ldots, q_n)$, such that $(a(q_1, \ldots, q_n)\rightarrow q) \in \delta)$ for any $a\in \Sigma$}
		{
			$S_q = \{ a\in \Sigma \,|\, \exists(a(q_1,\ldots,q_n) \rightarrow q) \in \delta\}$\;
			\ForEach{$(r_1,\ldots, r_n)$, such that $(b(r_1, \ldots, r_n)\rightarrow q) \in \delta)$ for any $a\in \Sigma$}
			{
				$S_r = \{a\in \Sigma \,|\, \exists\, (a(r_1,\ldots,r_n) \rightarrow q) \in \delta\}$\;
				\If{$(S_q \cap S_r \rightarrow A') \not\in f$ for any $A' \in \Sigma'$}
				{
					add $A'$ to $\Sigma'$ such that $A' \not\in \Sigma'$\;
					add $(S_q \cap S_r \rightarrow A')$ to $f$\;
				}
				add $f(S_q \cap S_r)(q_1,\ldots,) \rightarrow q$ to $\delta'$\;
			}
		}
    }
\caption{NTA symbol reduction yielding a new NTA}
\end{algorithm}

[TODO]
Finally, we compute downward simulation over explicit NTA by Algorithm \ref{alg:sim}.

\section{Implementation}
\label{sec:impl}

As we mentioned in Section \ref{sec:vata} VATA library already has infrastructure needed for implementation of
our method.
It contains support for parsing input NTA, its semi-symbolic and explicit representation and implemented
state-of-the-art algorithm for inclusion checking.
So we decided to implement our solution as extension of VATA library.
We design our implementation like a stand-alone module which is compiled seperately to the rest of library (using CMake building system exploited in VATA).
Module needs just include some headers for knowing interface of VATA classes for NTA representation.

When we focuse on implementation of our module itself we use following classes:
\begin{itemize}
	\item \emph{BDDTopDownSimExpl} Class translates MTBDD represented automaton to explicit one with symbol translation
	\item \emph{BDDBDDTopDownSimComputer} Class computes downward simulation over explicit tree automata
\end{itemize}

We exploited following classes from VATA implementation:

\begin{itemize}
	\item \emph{BDDTDTreeAutCore} Class for semi-symbolic representation of NTA using MTBDD.
	\item \emph{ExplicitTreeAutCore} Class for explicit representation of NTA.
	\item \emph{BinaryDiscontRelation} Class for representation of simulation relation.
\end{itemize}

\section{Experiments}
\label{sec:exps}

The experiments should find out how big efficien brings our method for computing simulation for checking inclusion of the tree automata.
The experiments was done by checking inclusion of language each automaton to other automata with and without simulation
and comparing needed times for checking inclusion depending on the number of states of the automata.
The for computing simulation was included into the time needed for checking inclusion with simulation
because it is not often possible to reuse once computed simulation.

We evalued our method on the set of [TODO: Number] automata.
The automata had from [TODO: number] to [TODO: Number] states.
The experiments was done computer with [TODO: configuration]

As you can see on Figure \ref{fig:res} the advantage of usage simulation is not still dominant.
Checking of language inclusion is faster only sometimes when the simulation is used.
We suppose that it is in cases when state explosion occured and checking without simulation
should go through whole state space.
This shows that symbol reduction and related transition reduction does not bring so big advatange
to equalize time neede to compute simulation.

\section{Conclusion}
\label{sec:end}

This works describes implementation of a method for computing simulation over NFA and its implementation.
Our method takes NTA represented in semi-symbolic top-down way using MTBDD, it
turns it to explicit representation and compute downward simulation over it.

We implemented our method as module to VATA library exploiting its infrastructure for manpilationg NTA.
The method has been evaluated on set of NTA and it has shown that our method and found that it is very awsome.
It 100000x faster then inclusion checking without simulation

Further research may be more efficient manipulation with MTBDD during traslation to explicit representation or
extending it to bottom-up automata.
It is also possible to implement NFA reduction which uses computed simulation.

\newpage
\appendix
\section{User guide}
\label{app:usage}

for installation please read README
for run, please read README-gal


\bibliography{literatura}
\bibliographystyle{plain}
\end{document}
